> 《Design Patterns in Modern C++》

# Design Patterns 

设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、  
让代码更容易被他人理解、保证代码可靠性、程序的重用性。

## SOLID 设计原则
----

* Single Responsibility Principle (SRP)  
    单一职责。
* Open-Closed Principle (OCP)  
    对扩展开放，对修改关闭。

* Liskov Substitution Principle(LSP)  
    里氏替换原则: 如果接口接受父类型, 也可以接受子类型, 不需要任何修改子类应该可以替换任何基类能够出现的地方,  
    并且经过替换以后，代码还能正常工作。

* Interface Segregation Principle(ISP)  
    接口隔离原则: 接口拆分(单一)

* Dependency Inversion Principle(DIP)  
    依赖倒置原则: 高级模块不应该依赖于低级模块，两者都应该依赖于抽象，抽象不应该依赖于细节。细节应该依赖于抽象。  
    面向接口，降低耦合（一个对象应对其他对象保持最小的了解，迪米特法则（Law of Demeter）又叫作最少知识原则）

## Creational Patterns 创造型模式  
----

### 1.Buidler

### 2.Factories  
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：  
虚函数）到子类。 ——《设计模式》GoF
* A class that knows how to create objects
* A function that, when called, creates an object
工厂方法是用作创建对象的一种方法的类成员，它通常替换构造函数。  
工厂通常是一个单独的类，它知道如何构造对象

### 3.Prototype

### 4.Singleton

## Structural Patterns 结构型模式
----
### 5.Adapter
将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 
### 6.Bridge

### 7.Composite

### 8.Decorator

### 9.Facade

### 10.Flyweight

### 11.Proxy

## Behavioral Patterns 行为型模式

### 12.Chain of Responsibility  
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

### 13.Command

### 14.Interpreter（解释器）  
Interpreter(解释器)模式是一种特殊的设计模式，它建立一个解释器（Interpreter），对于特定的计算机程序设计语言，用来解释预先定义的文法。尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。

### 15.Iterator  


### 16.Mediator（中介者）

### 17.Memento（备忘录）  
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。 ——《设计模式》GoF

### 18.Null Object  
Null Object模式主要是消除对null进行检查，并简化代码。

### 19.Observer  
定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

### 20.State
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类  
适用：  
1.一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为；  
2.一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。  
&emsp;通常有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象  
&emsp;自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其它对象而独立变化。  

如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统  
中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。

### 21.Strategy  
定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳  
定)而变化（扩展，子类化）。  
策略设计模式允许定义算法的框架，然后使用组合对象提供缺少的实现细节。

### 22.Template Method  
在父类中实现某个通用的流程，具体实现细节在各个特定的子类中实现。与策略Strategy类似，Strategy使用组合（静态、动态），  
Template Method使用继承。


### 23.Visitor  
表示一个作用与某对象结构中的各元素的操作。使得可以在不改变(稳定)各元素的类的前提下定义(扩展) 作用于这些元素的新操作(变化)。  

1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。   
2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。  
侵入，反射  
典型实现：double dispatch，visitor中实现visit()，对象中实现accept()  
Cyclic Visitor: 基于重载，访问者和类层次需互相认识（知道类型），用于稳定的类层次结构中  
Acyclic Visitor: 基于RTTI，对于对象层次没有限制，对性能有影响  


### 24.Maybe Monad
